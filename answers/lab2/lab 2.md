#lab 2
本次的实验主要是在实验一的基础上完成物理内存管理，并建立一个最简单的页表映射。
##知识点
##练习1：理解first-fit 连续物理内存分配算法
kern/mm/default_pmm.c中的相关代码，认真分析default_init，default_init_memmap，default_alloc_pages， default_free_pages等相关函数
###描述程序在进行物理内存分配的过程以及各个函数的作用。
分配过程基于首次适应（First-Fit）算法
####过程
1.初始化时，系统调用 default_init 函数清空空闲链表。
2.系统根据内存布局调用 default_init_memmap 函数，将一段内存块注册为可用的空闲内存。
3.当用户请求内存时，default_alloc_pages 函数会从空闲链表中寻找合适的内存块并分配。
4.需要释放内存时，default_free_pages 函数会将内存块重新放入空闲链表，并尝试合并相邻的空闲块。

####default_init（内存管理器的初始化）
该函数的主要任务是初始化内存的空闲链表 free_list，并将记录空闲页面数量的变量 nr_free 置为 0，供后续使用。
####default_init_memmap（内存块的添加）
负责将一段内存标记为可用并插入空闲列表中，这样这段内存就可以参与内存分配。
####default_alloc_pages（分配物理内存页）
通过遍历空闲链表，找到第一个能满足分配需求的内存块，并将它分配给用户，确保物理内存的有效利用。
####default_free_pages（释放物理内存页）
将每页的 flags 和 property 置为 0，标记它们为未使用。将该块插入空闲链表中，保持按地址排序。尝试合并相邻的空闲块，总的来说就是将内存块归还给系统并尝试合并相邻的内存块，以减少内存碎片化。

###设计实现过程。
代码中主要通过 default_alloc_pages(size_t n) 函数来实现First Fit算法。在这个函数中，程序会遍历存储空闲内存块的链表 free_list，找到第一个满足条件的内存块，将其分配并根据需要调整空闲链表。如果找到的空闲块比请求的还大，那么它会把多余的部分重新放回到空闲列表中。
大致过程就是：搜索合适的块、分配前n页、拆解比需求大的块重新插入链表、返回页面起始地址。

###你的first fit算法是否有进一步的改进空间？
从提高算法的效率和内存利用率方面考虑：
####维护不同大小的空闲块链表解决线性搜索方式在大量的内存块或内存分配/释放频繁的情况
####Best Fit 和 First Fit 的结合解决产生大量小碎片，导致后续的分配失败的问题
####分页机制的优化解决如果频繁分配和释放不同大小的内存块，可能会导致内存的不均衡分布的问题。

##练习2：实现 Best-Fit 连续物理内存分配算法（需要编程）
参考kern/mm/default_pmm.c对First Fit算法的实现，编程实现Best Fit页面分配算法
###设计实现过程
1.遍历空闲链表，寻找所有能够满足分配需求的内存块，并选择其中最小的那个块进行分配。
2.如果找到的块大于需求，则将剩余部分重新插入到空闲链表中。
3.如果没有找到合适的块，则返回 NULL。
###阐述代码是如何对物理内存进行分配和释放
####分配
检查：首先，函数检查当前系统中的空闲页数 nr_free 是否大于或等于请求的页数 n。如果空闲页数不足，直接返回 NULL，表示分配失败。

查找：从 free_list 链表的头开始遍历，查找能够满足请求大小的所有块。它记录找到的最小的满足条件的块（即 p->property >= n 且最小的块）。

分配：如果块的大小正好等于请求的大小，则直接分配整个块。如果块的大小大于请求的大小，则将剩余的部分拆分出来，并将剩余部分重新插入空闲链表。

更新：减少全局空闲页数 nr_free，清除已分配块的 PG_property 标志，最后返回分配的内存块的起始地址。
####释放

###你的 Best-Fit 算法是否有进一步的改进空间？


##扩展练习Challenge：buddy system（伙伴系统）分配算法（需要编程）
参考伙伴分配器的一个极简实现， 在ucore中实现buddy system分配算法，要求有比较充分的测试用例说明实现的正确性，需要有设计文档。

##扩展练习Challenge：任意大小的内存单元slub分配算法（需要编程）
slub算法，实现两层架构的高效内存单元分配，第一层是基于页大小的内存分配，第二层是在第一层基础上实现基于任意大小的内存分配。可简化实现，能够体现其主体思想即可。
###参考linux的slub分配算法/，在ucore中实现slub分配算法。要求有比较充分的测试用例说明实现的正确性，需要有设计文档。

##扩展练习Challenge：硬件的可用物理内存范围的获取方法（思考题）
###如果 OS 无法提前知道当前硬件的可用物理内存范围，请问你有何办法让 OS 获取可用物理内存范围？
通常，可以通过硬件提供的机制、固件接口、或者通过检测的方式让操作系统获取系统中的物理内存范围。
1.在基于 BIOS 的系统中，操作系统可以通过调用 INT 0x15, EAX=0xE820 来获取系统内存的布局。BIOS 会返回一个包含内存段类型和大小的列表，操作系统可以根据这个列表来知道哪些内存区域可用。
在基于 UEFI 的系统中，操作系统可以通过 UEFI Boot Services 提供的 GetMemoryMap() 函数来获取内存布局。UEFI 内存映射包含每个内存段的物理地址、大小和类型。

2.Multiboot 是一种操作系统引导协议，支持在不同硬件平台上引导操作系统。许多现代引导加载程序（如 GRUB）都支持 Multiboot 协议。操作系统通过 Multiboot 引导程序传递的信息来获取物理内存范围。

实现方式： Multiboot 引导加载程序会在启动时向操作系统传递内存映射等信息。操作系统可以在初始化时通过读取 Multiboot 信息来获取可用的物理内存范围。

3.ACPI（高级配置与电源接口）是现代计算机硬件配置管理的重要标准之一。ACPI 提供了丰富的硬件信息，操作系统可以通过 ACPI 表来获取内存信息。

实现方式： 操作系统可以读取 ACPI SRAT（系统资源分配表） 来获取物理内存布局。SRAT 表包含了可用的物理内存和每个内存块的类型。

4.手动检测（内存探测）

    概述： 操作系统还可以通过手动探测物理内存范围，尝试访问某些内存区域并根据是否成功来判断该区域是否可用。这个方法较为原始，通常用作辅助或者最后的尝试。

    实现方式： 操作系统可以尝试向某些物理地址写入和读取数据，如果操作成功且数据一致，说明该区域是可用的。否则，该区域可能已经被系统或硬件保留。

5.设备树（Device Tree）

    概述： 在某些嵌入式系统（如 ARM 架构）中，设备树（Device Tree） 可以提供硬件配置信息，包括可用的物理内存范围。设备树是一种数据结构，包含了内存和其他硬件资源的信息。

    实现方式： 操作系统在启动时解析设备树文件，并从中提取物理内存的相关信息。
